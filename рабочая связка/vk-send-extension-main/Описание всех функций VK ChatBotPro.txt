У нас есть готовый дизайн на языке разметки HTML для нашего расширения. Нам необходимо составить код сервера на Python для обеспечения работы наших сотрудников через нашего чат бота в расширении с целью одновременного сбора ответов для разных таблиц ответов в нашей базе данных. Так же нам необходимо прописать javascript-код который будет обеспечивать работу наших кнопок, функций, и связь с сервером. Клиентское расширение (JavaScript) общается с сервером (Python), который затем взаимодействует с базой данных SQLite. 


ДОПИСАТЬ ЛОГИКУ ПОЛУЧЕНИЯ НОВЫХ СООБЩЕНИЙ СО СТРАНИЦЫ ДИАЛОГА В РЕЖИМЕ РЕАЛЬНОГО ВРЕМЕНИ, ЧТОБЫ ЗАПИСЫВАТЬ ОТВЕТ ПОЛЬЗОВАТЕЛЯ В ТАБЛИЦУ ОТВЕТОВ Responses_(EmployeeID) ЭТОГО EmployeeID, УТОЧНЯТЬ ЧТО ЭТО СООБЩЕНИЯ НЕ ЯВЛЯЕТСЯ НАШИМ ЖЕ ВОПРОСОМ ИЗ НАШЕЙ ЖЕ ТАБЛИЦЫ Questions_(EmployeeID) ЭТОГО EmployeeID ИЛИ ЖЕ ОТПРАВЛЕННЫМИ СЛУЧАЙНЫМИ ЦИФРАМИ С ПОМОЩЬЮ НАШЕЙ КНОПКИ sendRandomButton
Для начала выводить эти сообщения в консоль нашего сервера на пайтон


Поле ввода "Вопросник №":  При открытии нашего расширения пользователь должен выбрать одну из таблиц Questions_(EmployeeID) с вопросами из нашей базы данных SQLite dialog.db указав номер от 1 до 2560. Полный путь к базе данных такой /Users/mykyta/Desktop/vk-send-extension-main/dialog.db 
Авторизация не требуется. 

   - Идентификатор поля ввода: `EmployeeID`

Существует 2560 вариантов таблиц Questions_(EmployeeID) с вопросами. Как для примера они называются Questions_1234. В самих таблицах Questions_(EmployeeID) вопросы обозначаются как Question, а номер вопроса обозначается как QuestionID. 

Кнопка "ОК": Нужно нажать кнопку ОК чтобы подключить расширение к этой базе данных вопросов Questions_(EmployeeID)
   - Идентификатор: `loadQuestionsButton`


Поле выбора задержки: Так же есть возможность определить с какой скоростью наш чат бот будет отправлять сообщения. Изначально установлено 10 секунд стандартной задержки. Можно выбрать задержку от 8 секунд до 15 секунд.

   - Идентификатор: `delaySelect`
   - Выпадающий список:
     - Содержит варианты задержки, представленные в элементах `<div class="custom-select-option">`
     - Атрибут данных значений вариантов: `data-value`


Кнопка "Продолжить": Чтобы продолжить работу нашего EmployeeID мы загружаем состояние из таблицы State. В этой таблице указывается какой ответ на вопрос чат бот обработал в CurrentQuestionID для данного EmployeeID. А так же номер работника (вопросника) - EmployeeID.  

   - Идентификатор: `continueButton`

После этого мы подключаем нужную нам таблицу Questions_EmployeeID для этого EmployeeID и начинаем по порядку отправлять наши вопросы из столбика Question с порядковыми номерами QuestionID. После того как мы находим, что на нашей странице появились новые элементы содержащие сообщения нашего собеседника, и он закончил писать мы копируем его ответ для таблицы ответов на вопросы. Мы записываем полученные от собеседника ответы на наши вопросы. Результатом работы расширения является заполнение наших таблиц ответов Responses_(EmployeeID) Их будет 2560 например Responses_1234

 В каждой таблице Responses_(EmployeeID) у нас должно сохраняться:
  ProcessedID - номер обработанного ответа
  QuestionText - текст вопроса
  AnswerText - текст ответа


После получения каждого нового ответа на вопросы должны сохранять прогресс работы над конкретной таблицой ответов. Мы записываем в таблице State сколько вопросов нам осталось задать, чтобы получить на них ответ в RemainingQuestions. И в самом расширении у нас должно отображаться состояние прохождения опроса. 

   - `<p id="remainingQuestionNumber">`: Параграф для отображения оставшегося количества вопросов для этого EmployeeID
   - `<p id="currentQuestionNumber">`: Параграф для отображения текущего номера вопроса для этого EmployeeID

Кнопка "Приостановить": При нажатии кнопки Приостановить мы останавливаемся на текущем вопросе. И ставим наш опросник на паузу. 
   - Идентификатор: `pauseButton` 


Кнопка "Начать заново": При нажатии этой кнопки мы должны стереть все записи из таблицы Responses_(EmployeeID) этого EmployeeID и начать заполнять ответы и вопросы заново, с первого вопроса. В таблице State мы обновляем наши значения оставшихся вопросов из таблицы Questions_(EmployeeID) записывая новое значение RemainingQuestions для данного EmployeeID и указываем что теперь текущий вопрос 0 в CurrentQuestionID

 Идентификатор `resetButton`


Кнопка "Скачать историю": Эта кнопка подготавливает файл для экспорта из расширения и скачивание в браузере, содержащий базу обработанных вопросов и ответы на них для данного EmployeeID из Responses_(EmployeeID) выводя информацию из ProcessedID, QuestionText, AnswerText доступный для скачивания из расширения в формате .txt 

В файле result.txt  должен указываться порядковый номер связки вопрос-ответ, а так же наш вопрос и полученный ответ. 

Идентификатор `downloadHistoryButton`


У нас есть всплывающее окно которое должно отображать статусы о работе нашего расширение. Сообщать о статусе успешной загрузки или не загрузки наших баз данных и выводить возможные ошибки. Допустим если не существует запрошенной базы вопросов Questions_(EmployeeID) для данного EmployeeID. Или выводить сообщения о недоступности определенных баз данных или других функций которые мы вызываем. Все наши ошибки должны выводится в этом всплывающем окне. Можно выводить с использованием кодов ошибок.

Всплывающее окно со статусом:
   - `<div id="statusPopup" class="status-popup">`: контейнер для всплывающего окна. По умолчанию он скрыт, но становится видимым, когда добавляется класс `active`.
   - `<p id="statusMessage">`: параграф для отображения сообщения о статусе во всплывающем окне


Кнопка "Отправить случайное сообщение": Отправляет случайное число

Идентификатор кнопки `sendRandomButton`

document.getElementById("sendRandomButton").addEventListener("click", function () {
  chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {
    let randomNumber = Math.floor(Math.random() * 10000000000).toString().padStart(10, "0");
    chrome.tabs.executeScript(tabs[0].id, {
      code: `
        var inputField = document.querySelector(".im_editable");
        if (inputField) {
          inputField.innerHTML = "${randomNumber}";
          var event = new KeyboardEvent('keydown', { key: 'Enter', code: 'Enter', keyCode: 13, which: 13, bubbles: true });
          inputField.dispatchEvent(event);
        }
      `,
    });
  });
});

Наша кнопка `sendRandomButton` является актуальным примером работающего функционала по вводу сообщений в поле для ввода и отправки их нашему собеседнику. 

